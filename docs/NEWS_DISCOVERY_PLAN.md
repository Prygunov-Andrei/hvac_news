# План реализации функционала автоматического поиска новостей

## Общее описание

Система автоматически ищет новости из списка источников через LLM API (OpenAI GPT-4o и Google Gemini), создает суммаризированные новости и сохраняет их как черновики для дальнейшего редактирования администратором.

---

## Этап 1: Модели данных

### 1.1. Расширение модели NewsPost

**Файл:** `news/models.py`

- Добавить поле `source_url` (URLField, nullable) для хранения ссылки на первоисточник новости
- Поле должно быть опциональным (blank=True, null=True)
- Добавить help_text: "URL оригинального источника новости"

**Миграция:** `news/migrations/0007_newspost_source_url.py`

---

### 1.2. Создание модели NewsDiscoveryRun

**Файл:** `news/models.py`

**Поля:**
- `last_search_date` (DateField) - дата последнего успешного поиска новостей
- `created_at` (DateTimeField, auto_now_add)
- `updated_at` (DateTimeField, auto_now)

**Методы класса:**
- `get_last_search_date()` - возвращает дату последнего поиска или сегодняшнюю дату, если поисков еще не было
- `update_last_search_date(date=None)` - обновляет дату последнего поиска (если date=None, использует сегодня)

**Meta:**
- verbose_name: "News Discovery Run"
- ordering: ['-last_search_date']

**Миграция:** `news/migrations/0008_newsdiscoveryrun.py`

---

### 1.3. Создание модели NewsDiscoveryStatus (для индикатора прогресса)

**Файл:** `news/models.py`

**Поля:**
- `processed_count` (IntegerField) - количество обработанных источников
- `total_count` (IntegerField) - общее количество источников
- `status` (CharField) - статус: 'running', 'completed', 'error'
- `created_at` (DateTimeField, auto_now_add)
- `updated_at` (DateTimeField, auto_now)

**Методы:**
- `get_progress_percent()` - возвращает процент выполнения (0-100)

**Миграция:** `news/migrations/0009_newsdiscoverystatus.py`

### 1.4. Регистрация в админке

**Файл:** `news/admin.py`

- Добавить `NewsDiscoveryRun` в админ-панель для просмотра истории поисков
- Добавить `NewsDiscoveryStatus` в админ-панель для просмотра текущего статуса (опционально)

---

## Этап 2: Сервис поиска новостей

### 2.1. Создание файла `news/discovery_service.py`

**Класс:** `NewsDiscoveryService`

**Инициализация:**
- Принимает `user` (опционально) - пользователь, который будет автором созданных новостей
- Читает API ключи из settings
- Настраивает модели: GPT-4o для OpenAI, Gemini 2.5 Flash для Google (gemini-2.5-flash) - модель доступна на бесплатном тарифе
- Настраивает таймауты: большие значения для надежной работы (например, 120 секунд для OpenAI, 120 секунд для Gemini)

**Константы:**
- `SUPPORTED_LANGUAGES = ['ru', 'en', 'de', 'pt']`

---

### 2.2. Метод `discover_news_for_resource(resource: NewsResource)`

**Логика работы:**
1. Получает период поиска: от `last_search_date` до `today` (включительно)
2. Формирует промпт для LLM через `_build_search_prompt()`
3. Параллельно отправляет запросы к OpenAI и Gemini через `_query_openai()` и `_query_gemini()`
4. Обрабатывает ошибки:
   - Если оба API упали → создает новость об ошибке через `_create_error_news()`
   - Если один работает → продолжает с его результатом
5. Объединяет ответы через `_merge_and_summarize()`
6. Создает новости через `_create_news_post()` для каждой найденной новости
7. Если новостей нет → создает новость "новостей не найдено" через `_create_no_news_news()`

**Возвращает:** `Tuple[int, int, Optional[str]]` - (created_count, error_count, error_message)

---

### 2.3. Метод `discover_all_news()`

**Логика работы:**
1. Создает или обновляет `NewsDiscoveryStatus` со статусом 'running'
2. Получает все источники из базы данных
3. Обновляет `total_count` в `NewsDiscoveryStatus`
4. Обрабатывает их последовательно через `discover_news_for_resource()`
5. После каждого источника обновляет `processed_count` в `NewsDiscoveryStatus`
6. При ошибке API:
   - Источник перемещается в конец очереди
   - Делается повторная попытка (максимум 1 раз)
   - Если повторная попытка не удалась → создается новость об ошибке
7. После успешного завершения всех источников:
   - Обновляет `last_search_date` через `NewsDiscoveryRun.update_last_search_date()`
   - Обновляет `NewsDiscoveryStatus` со статусом 'completed'
8. При критической ошибке обновляет `NewsDiscoveryStatus` со статусом 'error'

**Возвращает:** `Dict[str, int]` - `{'created': int, 'errors': int, 'total_processed': int}`

---

### 2.4. Вспомогательные методы

#### `_build_search_prompt(resource, start_date, end_date) -> str`
- Формирует промпт для LLM с информацией об источнике и периоде поиска

**Структура промпта:**
1. Роль: "Ты - эксперт по поиску новостей в области HVAC (отопление, вентиляция, кондиционирование) и холодильного оборудования"
2. Задача: "Найди все новости за период с {start_date} по {end_date} включительно на следующем ресурсе"
3. Информация об источнике:
   - Название ресурса: {resource.name}
   - URL ресурса: {resource.url}
   - Описание: {resource.description}
4. **КРИТИЧЕСКИЕ ИНСТРУКЦИИ:**
   - "Ищи новости ТОЛЬКО за указанный период"
   - "Любая статья, публикация, научная статья, пресс-релиз или любой другой контент, опубликованный на источнике за указанный период, считается новостью"
   - "Если новостей за этот период нет - верни пустой массив"
   - "Для каждой найденной новости создай краткое суммаризированное описание (1-2 абзаца)"
5. Формат ответа: JSON с переводами на все языки (ru, en, de, pt)
6. Пример структуры JSON ответа

#### `_query_openai(prompt) -> Optional[Dict]`
- Отправляет запрос к OpenAI API (GPT-4o)
- Использует `response_format={"type": "json_object"}` для гарантированного JSON
- Устанавливает таймаут: 120 секунд (медленно но надежно)
- Парсит JSON ответ
- Обрабатывает ошибки (логирование, исключения)

#### `_query_gemini(prompt) -> Optional[Dict]`
- Отправляет запрос к Google Gemini API (модель: gemini-2.5-flash - доступна на бесплатном тарифе)
- Использует `response_mime_type="application/json"` для JSON ответа
- Устанавливает таймаут: 120 секунд (медленно но надежно)
- Убирает возможные markdown обертки (```json)
- Парсит JSON ответ
- Обрабатывает ошибки (логирование, исключения)

#### `_merge_and_summarize(openai_response, gemini_response, resource) -> List[Dict]`
- Объединяет новости из обоих ответов
- Убирает дубликаты по `source_url`
- Если новостей много или ответы различаются → делает финальную суммаризацию через OpenAI
- Возвращает список уникальных новостей

#### `_build_merge_prompt(news_items, resource) -> str`
- Формирует промпт для финальной суммаризации объединенных новостей
- Просит улучшить суммаризацию и убедиться в полноте переводов

#### `_create_news_post(news_item: Dict, resource: NewsResource)`
- Создает новость `NewsPost` со статусом `draft`
- Заполняет поля `title` и `body` на русском языке
- Устанавливает переводы через modeltranslation (title_en, title_de, title_pt, body_en, body_de, body_pt)
- Устанавливает `source_url`, `source_language='ru'`, `author`

#### `_create_no_news_news(resource, start_date, end_date)`
- Создает новость о том, что новостей не найдено
- Заполняет переводы на все языки
- Устанавливает `source_url = resource.url`

#### `_create_error_news(resource, error_message)`
- Создает новость об ошибке при поиске
- Заполняет переводы на все языки
- Устанавливает `source_url = resource.url`

---

### 2.5. Формат JSON ответа от LLM

```json
{
  "news": [
    {
      "title": {
        "ru": "Заголовок новости на русском",
        "en": "News title in English",
        "de": "Nachrichtentitel auf Deutsch",
        "pt": "Título da notícia em português"
      },
      "summary": {
        "ru": "Краткое описание новости на русском языке (1-2 абзаца)",
        "en": "Brief news summary in English (1-2 paragraphs)",
        "de": "Kurze Nachrichtenzusammenfassung auf Deutsch (1-2 Absätze)",
        "pt": "Resumo breve da notícia em português (1-2 parágrafos)"
      },
      "source_url": "https://example.com/news/article"
    }
  ]
}
```

Если новостей нет: `{"news": []}`

---

## Этап 3: Настройки и зависимости

### 3.1. Обновление `config/settings.py`

Добавить настройки:
```python
# News Discovery Configuration
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY', '')  # Установите в .env файле
NEWS_DISCOVERY_OPENAI_MODEL = os.getenv('NEWS_DISCOVERY_OPENAI_MODEL', 'gpt-4o')
NEWS_DISCOVERY_GEMINI_MODEL = os.getenv('NEWS_DISCOVERY_GEMINI_MODEL', 'gemini-2.5-flash')  # Доступна на бесплатном тарифе
NEWS_DISCOVERY_TIMEOUT = int(os.getenv('NEWS_DISCOVERY_TIMEOUT', '120'))  # Таймаут в секундах
```

---

### 3.2. Обновление `requirements.txt`

Добавить зависимость:
```
google-generativeai>=0.3.0
```

---

## Этап 4: Админ-интерфейс

### 4.1. Расширение `references/admin.py`

**Добавить метод `get_urls()`:**
- Добавить маршрут `discover-news/` → метод `discover_news`

**Метод `discover_news(request)`:**
- **GET запрос:** Отображает страницу подтверждения с информацией:
  - Дата последнего поиска
  - Период поиска (с ... по ...)
  - Количество источников для обработки
  - Кнопка подтверждения
- **POST запрос:** 
  - Запускает `NewsDiscoveryService.discover_all_news()` в фоновом режиме (или синхронно с индикатором прогресса)
  - **ВАЖНО:** Реализовать индикатор прогресса (обработано X из Y источников)
  - Отображает результаты через `message_user()`
  - Редирект обратно на список источников

---

### 4.2. Обновление шаблона `references/templates/admin/newsresource_changelist.html`

Добавить кнопку в блок `object-tools-items`:
```html
<li>
    <a href="discover-news/" class="addlink">Найти новости</a>
</li>
```

---

### 4.3. Создание шаблона `references/templates/admin/discover_news.html`

**Содержимое:**
- Заголовок: "Поиск новостей"
- Информация о периоде поиска
- Количество источников
- Форма с кнопкой подтверждения (POST запрос)
- Кнопка отмены (возврат к списку)

### 4.4. Индикатор прогресса

**Реализация индикатора прогресса:**
- Использовать модель `NewsDiscoveryStatus` для хранения текущего статуса
- В методе `discover_news()` после запуска `discover_all_news()`:
  - Создать `NewsDiscoveryStatus` объект
  - Вернуть страницу с JavaScript, который периодически (каждые 2-3 секунды) опрашивает статус
- Создать API endpoint `get_discovery_status()` для получения текущего статуса
- JavaScript обновляет прогресс-бар на основе полученных данных
- После завершения показывать результаты и редирект на список источников

**API endpoint:** `references/admin.py` → метод `get_discovery_status(request)`
- Возвращает JSON: `{'processed': int, 'total': int, 'status': str, 'percent': float}`
- Маршрут: `discover-news-status/`

**Детали реализации индикатора прогресса:**

1. **В методе `discover_news()` (POST):**
   - Создать `NewsDiscoveryStatus` объект перед запуском поиска
   - Запустить `discover_all_news()` (синхронно или в отдельном потоке)
   - Вернуть страницу с JavaScript для отслеживания прогресса

2. **В методе `discover_all_news()`:**
   - Обновлять `NewsDiscoveryStatus.processed_count` после каждого обработанного источника
   - Обновлять `NewsDiscoveryStatus.status` ('running' → 'completed' или 'error')

3. **В шаблоне `discover_news.html` (после POST):**
   - Показать прогресс-бар с начальным значением 0%
   - JavaScript каждые 2-3 секунды делает AJAX запрос к `get_discovery_status()`
   - Обновляет прогресс-бар и текст "Обработано X из Y источников"
   - Когда статус = 'completed' или 'error' → показать результаты и редирект

4. **Альтернативный вариант (проще):**
   - Запускать поиск синхронно с обновлением статуса в базе
   - Показывать страницу с автоматическим обновлением через JavaScript
   - После завершения показать результаты

---

## Этап 5: Логика работы

### 5.1. Определение периода поиска

- **Первый запуск:** Если `NewsDiscoveryRun` не существует → период = с сегодняшнего дня по сегодня
- **Последующие запуски:** Период = с `last_search_date` (включительно) по сегодня (включительно)

---

### 5.2. Обработка источников

1. Получаем все источники из `NewsResource.objects.all()`
2. Обрабатываем последовательно каждый источник:
   - Вызываем `discover_news_for_resource(resource)`
   - При ошибке API → источник в конец очереди для повтора
   - После обработки всех источников → обрабатываем очередь повторов (максимум 1 попытка)
3. После успешного завершения → обновляем `last_search_date` на сегодня

---

### 5.3. Создание новостей

**Параметры новости:**
- `status = 'draft'` (черновик)
- `author = user` (пользователь, запустивший поиск)
- `source_language = 'ru'` (основной язык)
- `source_url` - ссылка на первоисточник
- `title` и `body` заполняются на всех языках из JSON ответа
- `pub_date = timezone.now()` (можно изменить админом позже)

---

### 5.4. Обновление даты поиска

После успешного завершения всех источников:
```python
NewsDiscoveryRun.update_last_search_date(timezone.now().date())
```

---

## Этап 6: Обработка ошибок

### 6.1. Ошибки API

**OpenAI ошибка:**
- Логируется через `logger.error()`
- Пытаемся использовать ответ от Gemini
- Если Gemini тоже упал → создаем новость об ошибке

**Gemini ошибка:**
- Логируется через `logger.error()`
- Пытаемся использовать ответ от OpenAI
- Если OpenAI тоже упал → создаем новость об ошибке

**Оба API упали:**
- Создается новость об ошибке через `_create_error_news()`
- Источник перемещается в конец очереди для повторной попытки
- После повторной попытки (если снова ошибка) → создается новость об ошибке

---

### 6.2. Ошибки обработки данных

**Некорректный JSON:**
- Логируется через `logger.error()`
- Создается новость об ошибке обработки (черновик) - это и есть лог

**Ошибка создания новости:**
- Логируется через `logger.error()`
- Создается новость об ошибке (черновик) - это и есть лог
- Продолжаем обработку следующего источника

---

### 6.3. Повторные попытки

- Максимум 1 повторная попытка для источника с ошибкой API
- После повторной ошибки → создается новость об ошибке, источник пропускается

---

## Этап 7: Тестирование

### 7.1. Тестовые сценарии

1. **Поиск для одного источника с новостями:**
   - Проверить создание новостей со статусом draft
   - Проверить заполнение всех языков
   - Проверить наличие source_url

2. **Поиск для источника без новостей:**
   - Проверить создание новости "новостей не найдено"

3. **Ошибка одного API (OpenAI или Gemini):**
   - Проверить использование ответа от рабочего API
   - Проверить создание новостей

4. **Ошибка обоих API:**
   - Проверить создание новости об ошибке
   - Проверить повторную попытку

5. **Первый запуск (нет last_search_date):**
   - Проверить период поиска (сегодня → сегодня)

6. **Повторный запуск (есть last_search_date):**
   - Проверить период поиска (last_search_date → сегодня)
   - Проверить обновление last_search_date после завершения

---

## Ответы на вопросы (обновлено)

1. ✅ **Промпт для LLM:** 
   - Передавать временной интервал (с start_date по end_date включительно)
   - Указать: "Любая статья, публикация, научная статья или любой другой контент, опубликованный на источнике за указанный период, считается новостью"
   - Указать: "Каждую найденную новость необходимо суммаризировать в 1-2 абзаца"

2. ✅ **Gemini модель:** Использовать `gemini-2.5-flash` (Gemini 2.5 Flash) - доступна на бесплатном тарифе с квотой 250 запросов/день

3. ✅ **Таймауты:** Установить большие таймауты (120 секунд) для надежной работы - система должна работать медленно но надежно

4. ✅ **Логирование:** Нет отдельного лог-файла. Все события (найдены новости, новостей нет, ошибки) создаются как черновики новостей - это и есть лог. Админ вручную удалит лишнее.

5. ✅ **Прогресс:** Да, нужен индикатор прогресса в админке (обработано X из Y источников)

---

## Порядок реализации

1. ✅ Этап 1: Модели данных (уже выполнено частично)
2. ⏳ Этап 2: Сервис поиска новостей (уже выполнено частично)
3. ⏳ Этап 3: Настройки и зависимости (уже выполнено частично)
4. ⏳ Этап 4: Админ-интерфейс (уже выполнено частично)
5. ⏳ Этап 5: Логика работы (требует доработки)
6. ⏳ Этап 6: Обработка ошибок (требует доработки)
7. ⏳ Этап 7: Тестирование

---

## Примечания

- Все новости создаются со статусом `draft` для ручного редактирования администратором
- Система не проверяет дубликаты - администратор увидит их вручную
- При отсутствии новостей создается специальная новость об этом (черновик) - это лог
- При ошибках API создаются новости об ошибках (черновики) - это лог
- Все события (новости, отсутствие новостей, ошибки) создаются как черновики - это и есть система логирования
- Администратор вручную удалит лишние черновики после просмотра
- Система работает медленно но надежно - большие таймауты для API запросов
- Индикатор прогресса позволяет отслеживать процесс обработки источников в реальном времени
